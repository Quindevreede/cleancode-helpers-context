{\rtf1\ansi\ansicpg1252\deff0\nouicompat\deflang2057{\fonttbl{\f0\fnil\fcharset0 Calibri;}{\f1\fmodern JetBrains Mono;}}
{\colortbl ;\red204\green120\blue50;\red152\green118\blue170;\red169\green183\blue198;\red255\green198\blue109;\red106\green135\blue89;\red232\green191\blue106;\red128\green128\blue128;\red186\green186\blue186;\red102\green102\blue102;\red104\green151\blue187;}
{\*\generator Riched20 10.0.19041}\viewkind4\uc1 
\pard\sa200\sl276\slmult1\b\f0\fs28\lang9 STAPPENPLAN EXTRA III voor WEATHER_APP :\line --------------------------------------------------------------\line\line\ul CONTEXT :\line\line\ulnone\fs40 PROVIDER GEDEELTE :::\ul\fs28\line STAP 1 :\line\ulnone\b0 We maken nu de CONTEXT en beginnen hier:\ul\b\par
\ulnone\b0 >>>> Maak een map genaamd context aan in de src-map\par
  >>> Maak in die map een bestand genaamd TempProvider.js (Let op: \line           m\'e9t hoofdletter)\par
    >>  In dit bestand beginnen we met het cre\'ebren van een TempContext \line           met de createContext functie. Deze krijgt een initiele waarde van \line           null\par
       > Zet het woordje export voor const. We hebben onze context straks \line           immers ergens anders nodig!\par

\pard\box\brdrdash\brdrw0 \sa200\sl276\slmult1\cf1\f1\fs20 import \cf2\b\i React\cf1\b0\i0 , \cf3\{ \cf4 createContext \cf3\} \cf1 from \cf5 'react'\cf1 ;\line\line export const \cf2\b\i TempContext\f0\lang1033 Provider\f1\lang9  \cf3\b0\i0 = \cf4 createContext\cf3 (\cf1 null\cf3 )\cf1 ;\line\line function \cf4 TempContextProvider\cf3 (\{ children \}) \{\}\par
\cf0\ul\b\f0\fs28 STAP 2 :\line\ulnone\b0 >>>> Maak in index.js de CONTEXT om de <App /> heen:\line\line\cf3\f1\fs20 ReactDOM.\cf2\b\i render\cf3\b0\i0 (\line     \cf6 <React.StrictMode>\line         <TempContextProvider>\line             <App />\line         </TempContextProvider>\line     </React.StrictMode>\cf1 ,\line     \cf2\b\i document\cf3\b0\i0 .\cf4 getElementById\cf3 (\cf5 'root'\cf3 )\line )\cf1 ;\par
\cf0\ul\b\f0\fs28 STAP 3.1 :\line\ulnone\b0 >>>> We gaan terug naar TempProvider.js en voegen een RETURN ( toe\line\line\cf1\f1\fs20 import \cf2\b\i React\cf1\b0\i0 , \cf3\{ \cf4 createContext \cf3\} \cf1 from \cf5 'react'\cf1 ;\line\line export const \cf2\b\i TempContext \cf3\b0\i0 = \cf4 createContext\cf3 (\cf1 null\cf3 )\cf1 ;\line\line function \cf4 TempContextProvider\cf3 () \{\line     \cf7 // hier komt straks de state waarin we de context-data plaatsen\line\line     \cf1 return \cf3 (\line         \cf6 <TempContext.Provider \cf8 value\cf5 =\cf3\{\}\cf6 >\line             \cf3 // hier komt het component waar we onze eigen provider omheen wikkelen\line         \cf6 </TempContext.Provider>\line     \cf3 )\line\}\line\line\cf1 export default \cf4 TempContextProvider\cf1 ;\par
\cf0\ul\b\f0\fs28 STAP 3.2 :\ulnone\b0\line >>>> We voegen in TempProvider.js ook nog de waarde \{ children \} toe,\line           deze children zijn dus de dingen die binnen de function vallen\line\line\cf1\f1\fs20 import \cf2\b\i React\cf1\b0\i0 , \cf3\{ \cf4 createContext \cf3\} \cf1 from \cf5 'react'\cf1 ;\line\line export const \cf2\b\i TempContext \cf3\b0\i0 = \cf4 createContext\cf3 (\cf1 null\cf3 )\cf1 ;\line\line function \cf4 TempContextProvider\cf3 (\f0\lang1033  \cf0\b\{ children \} \cf3\b0\f1\lang9 ) \{\line     \cf7 // hier komt straks de state waarin we de context-data plaatsen\line\line     \cf1 return \cf3 (\line         \cf6 <TempContext.Provider \cf8 value\cf5 =\cf3\{\}\cf6 >\line            \cf0\b\f0\lang1033\{ children \} \f1\lang9\line\cf3\b0         \cf6 </TempContext.Provider>\line     \cf3 )\line\}\line\line\cf1 export default \cf4 TempContextProvider\cf1 ;\par
\cf0\ul\b\f0\fs28 STAP 4.1 :\line\line\ulnone\b0 >>>>> Maak in het TempContextProvider-component een stukje state aan met de key selectedMetric, waarbij de initi\'eble waarde de string 'celcius' is.\par
\cf9\i We willen er straks voor zorgen dat ons <MetricSlider>-component gebruik kan maken van de setter-functie om de selectedMetric te veranderen. Om de selectedMetric te kunnen veranderen, moeten we ons echter bewust zijn van de huidige selectedMetric. Als het Celcius is moet het naar Fahrenheit, en als het Fahrenheit is moet het naar Celcius. \cf0 Een belangrijke regel met Context is dat je altijd wil proberen om alle logica in het Provider component te houden. \cf9 We willen liever niet dat Consumer-componenten zelf moeten gaan beredeneren welke nieuwe eenheid er in de state geplaatst moet worden. Dit zou namelijk ook een hoop dubbele code opleveren. Daarom schrijven we een dergelijke functie, die gebruik maakt van onze state setter functie, direct uit in het Provider component:\line\line\cf1\i0\f1\fs20 function \cf4 TempContextProvider\cf3 (\{ children \}) \{\line     \cf1 const \cf3 [selectedMetric\cf1 , \cf3 toggleSelectedMetric]\f0\lang1033  = \f1\lang9 useState(\cf5 'celcius'\cf3 )\cf1 ;\line\line     function \cf4 toggleTemp\cf3 () \{\line         \cf1 if \cf3 (selectedMetric === \cf5 'celcius'\cf3 ) \{\line             toggleSelectedMetric(\cf5 'fahrenheit'\cf3 )\cf1 ;\line         \cf3\} \cf1 else \cf3\{\line             toggleSelectedMetric(\cf5 'celcius'\cf3 )\cf1 ;\line         \cf3\}\line     \}\line\line     \cf1 return \cf3 (\line         \cf7 //...\line     \cf3 )\cf1 ;\par
\cf0\ul\b\f0\fs28 STAP 4.2 :\ulnone\b0\line >>>>>  We willen er ook voor zorgen dat we, op basis van de geselecteerde eenheid, ook de juiste omreken-functie in de Context plaatsen. We gebruiken nu overal de kelvinToCelcius functie, maar we zullen dus ook een helper-functie nodig hebben om Kelvin naar Fahrenheit om te rekenen!\line\line > Maak een nieuw bestandje in de helpers-map en noem deze \line    kelvinToFahrenheit.js\par
> Schrijf en exporteer hierin een functie die kelvin als parameter \line    verwacht en een fahrenheit string teruggeeft. \line\line\cf1\f1\fs20 function \cf4 kelvinToFahrenheit\cf3 (kelvin) \{\line     \cf1 return \cf5 `\cf3 $\{\cf2\b\i Math\cf3\b0\i0 .\cf4 round\cf3 ((kelvin - \cf10 273.15\cf3 ) * \cf10 1.8\cf3 ) + \cf10 32\cf3\}\cf5\f0\'b0\f1  F`\cf1 ;\line\cf3\}\line\line\cf1 export default \cf4 kelvinToFahrenheit\cf1 ;\par
\cf0\ul\b\f0\fs28 STAP 4.3 :\ulnone\b0\line >>>>> Importeer nu beide helper-functies in TempContextProvider.js:\line\line We gaan ons value-attribuut vullen met een object, zodat we zowel onze toggleTemp als de helper-functies kunnen doorgeven:\line\line\cf1\f1\fs20 return \cf3 (\line     \cf6 <TempContext.Provider\line         \cf8 value\cf5 =\cf3\{\{\line             toggleTemp: toggleTemp\cf1 ,\line             \cf3 kelvinToMetric: selectedMetric === \cf5 'celcius' \cf3 ? kelvinToCelcius : kelvinToFahrenheit\cf1 ,\line         \cf3\}\}\line     \cf6 >\line         \cf3\{ children \}\line     \cf6 </TempContext.Provider>\line\cf3 )\par
\cf0\f0\fs28 Zoals je ziet geven we, op basis van de waarde van de \b selectedMetric\b0 , respectievelijk de functie kelvinToCelcius of kelvinToFahrenheit mee. Ook nu hoeven de componenten die deze functie gaan gebruiken, zich niet bezig houden met de logica. Ze hoeven slechts de \b kelvinToMetric functie \b0 te gebruiken zonder zich bewust te zijn van de huidig geselecteerde eenheid.\par
\cf9\i Side note: als de object key dezelfde naam heeft als de variabele die je er in stopt \{ toggleTemp: toggleTemp \} mag je er ook \'e9\'e9ntje weglaten: \{ toggleTemp \}. De werking blijft hetzelfde!\line\line\cf0\i0 DE TEMPCONTEXTPROVIDER.JS ZIET ER NU ZO UIT :\par
\cf1\f1\fs20 import \cf2\b\i React\cf1\b0\i0 , \cf3\{ \cf4 createContext\cf1 , \cf4 useState \cf3\} \cf1 from \cf5 'react'\cf1 ;\line import \cf3 kelvinToCelcius \cf1 from \cf5 '../helpers/kelvinToCelcius'\cf1 ;\line import \cf3 kelvinToFahrenheit \cf1 from \cf5 '../helpers/kelvinToFahrenheit'\cf1 ;\line\line export const \cf2\b\i TempContext \cf3\b0\i0 = \cf4 createContext\cf3 (\cf1 null\cf3 )\cf1 ;\line\line function \cf4 TempContextProvider\cf3 (\{ children \}) \{\line     \cf1 const \cf3 [selectedMetric\cf1 , \cf3 toggleSelectedMetric] = \cf4 useState\cf3 (\cf5 'celcius'\cf3 )\cf1 ;\line\line     function \cf4 toggleTemp\cf3 () \{\line         \cf1 if \cf3 (selectedMetric === \cf5 'celcius'\cf3 ) \{\line             toggleSelectedMetric(\cf5 'fahrenheit'\cf3 )\cf1 ;\line         \cf3\} \cf1 else \cf3\{\line             toggleSelectedMetric(\cf5 'celcius'\cf3 )\cf1 ;\line         \cf3\}\line     \}\line\line     \cf1 return \cf3 (\line         \cf6 <TempContext.Provider \cf8 value\cf5 =\cf3\{\{\line             \cf4 toggleTemp\cf3 : \cf4 toggleTemp\cf1 ,\line             \cf2 kelvinToMetric\cf3 : selectedMetric === \cf5 'celcius' \cf3 ? kelvinToCelcius : kelvinToFahrenheit\cf1 ,\line         \cf3\}\}\cf6 >\line             \cf3\{ children \}\line         \cf6 </TempContext.Provider>\line     \cf3 )\line\}\line\line\cf1 export default \cf4 TempContextProvider\cf1 ;\line\line\cf0\f0\fs22 We hebben nu Context aangemaakt, een Provider component opgezet die data in de Context zet en deze om ons <App>-component gewikkeld. Het is tijd voor het Consumer-gedeelte. Er is nu immers nog geen enkel component die onze Context gebruikt. Laten we daar verandering in brengen.\cf1\f1\par
\cf0\b\f0\fs40 CONSUMER GEDEELTE :::\line\ul\fs28 STAP 5.1 :\ulnone\b0\line >>>>> Open ForecastTab.js. We hebben twee dingen nodig\par
1. - Onze TempContext\par
2. - De useContext hook van React\par
>>>> Importeer beiden bovenaan het bestand.\par
Het enige wat we nu hoeven te doen, is onze functie die we onder de key kelvinToMetric in de Context hebben gezet, weer te \b destructuren\b0  uit de Context:\line\line\cf1\f1\fs20 import \cf2\b\i React\cf1\b0\i0 , \cf3\{ \cf4 useEffect\cf1 , \cf4 useState\cf1 , \cf4 useContext \cf3\} \cf1 from \cf5 'react'\cf1 ;\line import \cf3\{ TempContext \} \cf1 from \cf5 '../../context/TempContextProvider'\cf1 ;\line\line const \cf3\{ kelvinToMetric \} = \cf4 useContext\cf3 (TempContext)\cf1 ;\par
\cf0\ul\b\f0\fs28 STAP 5.2 :\ulnone\b0\line >>>>> Vervang nu de kelvinToCelcius functie door onze kelvinToMetric functie uit de Context.\line\line\cf6\f1\fs20 <section \cf8 className\cf5 ="forecast-weather"\cf6 >\line   <span>\line     \cf3\{kelvinToMetric(forecast.temp.\cf2 day\cf3 )\}\line   \cf6 </span>\par
\cf0\ul\b\f0\fs28 STAP 5.3 :\ulnone\b0\line >>>>> \line > Open nu WeatherDetail.js en importeer daar ook de TempContext en \line    de useContext hook\par
> Haal ook hier de kelvinToMetric functie uit de context en vervang \line    kelvinToCelcius.\par
> In App.js wordt ook nog een kelvinToCelcius functie gebruikt. Vervang \line    deze ook door onze Context-omreken-functie.\line\line\ul\b STAP 6 :\ulnone\b0\line >>>>> \line Nu gaan we onze slider ook nog abonneren op de Context. Open MetricSlider.js. Zoals je ziet, is onze slider eigenlijk een checkbox die door CSS het uiterlijk van een slider heeft gekregen. Om onze slider functioneel te maken, moeten we er eerst een controlled component van maken.\par
> Maak van de checkbox een controlled component door een stukje state \line    aan te maken die toggled tussen true en false. De initi\'eble waarde is \line    true.\par
> Importeer de TempContext en de useContext hook en destructure daar \line    de toggleTemp functie uit\par
> Zorg ervoor dat wanneer de state van de checkbox veranderd, de \line    toggleTemp functie wordt aangeroepen (tip: gebruik een Life Cycle \line    method!)\par
Als het goed is, heb je dit op de volgende manier gedaan:\par
\cf1\f1\fs20 const \cf4 MetricSlider \cf3 = () => \{\line     \cf1 const \cf3 [checked\cf1 , \cf3 toggleChecked] = useState(\cf1 true\cf3 )\cf1 ;\line     const \cf3\{ toggleTemp \} = useContext(TempContext)\cf1 ;\line\line     \cf3 useEffect(() => \{\line         toggleTemp()\cf1 ;\line     \cf3\}\cf1 , \cf3 [checked])\cf1 ;\line\line     return \cf3 (\line         \cf6 <input\line             \cf8 type\cf5 ="checkbox"\line             \cf8 className\cf5 ="switch"\line             \cf8 id\cf5 ="metric-system"\line             \cf8 checked\cf5 =\cf3\{checked\}\line             \cf8 onChange\cf5 =\cf3\{() => toggleChecked(!checked)\}\line         \cf6 />\line     \cf3 )\cf1 ;\line\cf3\}\par
\cf0\f0\fs28\par
}
 